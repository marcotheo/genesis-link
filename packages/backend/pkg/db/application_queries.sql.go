// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: application_queries.sql

package db

import (
	"context"
	"database/sql"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    applicationId, 
    proposalLink, 
    status, 
    postId, 
    userId, 
    created_at, 
    updated_at
) VALUES (
    ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING applicationid, proposallink, status, postid, userid, created_at, updated_at
`

type CreateApplicationParams struct {
	Applicationid string
	Proposallink  sql.NullString
	Status        string
	Postid        string
	Userid        string
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, createApplication,
		arg.Applicationid,
		arg.Proposallink,
		arg.Status,
		arg.Postid,
		arg.Userid,
	)
	var i Application
	err := row.Scan(
		&i.Applicationid,
		&i.Proposallink,
		&i.Status,
		&i.Postid,
		&i.Userid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicationsByPostId = `-- name: GetApplicationsByPostId :many
SELECT
    u.firstName,
    u.lastName,
    u.email,
    u.mobileNumber,
    a.userId,
    a.applicationId,
    a.status,
    a.created_at
FROM applications a
LEFT JOIN users u ON a.userId = u.userId
WHERE a.postId = ?
ORDER BY a.created_at DESC
LIMIT ? OFFSET ?
`

type GetApplicationsByPostIdParams struct {
	Postid string
	Limit  int64
	Offset int64
}

type GetApplicationsByPostIdRow struct {
	Firstname     sql.NullString
	Lastname      sql.NullString
	Email         sql.NullString
	Mobilenumber  sql.NullString
	Userid        string
	Applicationid string
	Status        string
	CreatedAt     sql.NullTime
}

func (q *Queries) GetApplicationsByPostId(ctx context.Context, arg GetApplicationsByPostIdParams) ([]GetApplicationsByPostIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByPostId, arg.Postid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationsByPostIdRow
	for rows.Next() {
		var i GetApplicationsByPostIdRow
		if err := rows.Scan(
			&i.Firstname,
			&i.Lastname,
			&i.Email,
			&i.Mobilenumber,
			&i.Userid,
			&i.Applicationid,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByPostIdCount = `-- name: GetApplicationsByPostIdCount :one
SELECT  
    COUNT(*) AS total_count
FROM applications
WHERE postId = ?
`

func (q *Queries) GetApplicationsByPostIdCount(ctx context.Context, postid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getApplicationsByPostIdCount, postid)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getApplicationsByUserId = `-- name: GetApplicationsByUserId :many
SELECT
    o.company,
    p.title,
    a.applicationId,
    a.status,
    a.postId,
    a.created_at
FROM applications a
LEFT JOIN posts p ON a.postId = p.postId
LEFT JOIN organizations o ON p.orgId = o.orgId
WHERE a.userId = ?
ORDER BY a.created_at DESC
LIMIT ? OFFSET ?
`

type GetApplicationsByUserIdParams struct {
	Userid string
	Limit  int64
	Offset int64
}

type GetApplicationsByUserIdRow struct {
	Company       sql.NullString
	Title         sql.NullString
	Applicationid string
	Status        string
	Postid        string
	CreatedAt     sql.NullTime
}

func (q *Queries) GetApplicationsByUserId(ctx context.Context, arg GetApplicationsByUserIdParams) ([]GetApplicationsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByUserId, arg.Userid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationsByUserIdRow
	for rows.Next() {
		var i GetApplicationsByUserIdRow
		if err := rows.Scan(
			&i.Company,
			&i.Title,
			&i.Applicationid,
			&i.Status,
			&i.Postid,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByUserIdCount = `-- name: GetApplicationsByUserIdCount :one
SELECT  
    COUNT(*) AS total_count
FROM applications
WHERE userId = ?
`

func (q *Queries) GetApplicationsByUserIdCount(ctx context.Context, userid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getApplicationsByUserIdCount, userid)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getProposalLinkByApplicationId = `-- name: GetProposalLinkByApplicationId :one
SELECT
    proposalLink
FROM applications
WHERE applicationId = ?
`

func (q *Queries) GetProposalLinkByApplicationId(ctx context.Context, applicationid string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getProposalLinkByApplicationId, applicationid)
	var proposallink sql.NullString
	err := row.Scan(&proposallink)
	return proposallink, err
}

const getResumeLinkByApplicationId = `-- name: GetResumeLinkByApplicationId :one
SELECT
    u.resumeLink
FROM applications a
LEFT JOIN users u ON a.userId = u.userId
WHERE a.applicationId = ?
`

func (q *Queries) GetResumeLinkByApplicationId(ctx context.Context, applicationid string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getResumeLinkByApplicationId, applicationid)
	var resumelink sql.NullString
	err := row.Scan(&resumelink)
	return resumelink, err
}
