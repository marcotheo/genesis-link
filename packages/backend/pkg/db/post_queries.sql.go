// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: post_queries.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const checkIfPostExistByOrg = `-- name: CheckIfPostExistByOrg :one
SELECT postId FROM posts
WHERE postId = ? AND orgId = ?
`

type CheckIfPostExistByOrgParams struct {
	Postid string
	Orgid  string
}

func (q *Queries) CheckIfPostExistByOrg(ctx context.Context, arg CheckIfPostExistByOrgParams) (string, error) {
	row := q.db.QueryRowContext(ctx, checkIfPostExistByOrg, arg.Postid, arg.Orgid)
	var postid string
	err := row.Scan(&postid)
	return postid, err
}

const createJobDetails = `-- name: CreateJobDetails :exec
INSERT INTO job_details (
    jobDetailId,
    postId,
    jobType,
    salaryType,
    salaryAmountMin,
    salaryAmountMax,
    salaryCurrency
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
RETURNING jobdetailid, postid, jobtype, salarytype, salaryamountmin, salaryamountmax, salarycurrency, created_at, updated_at
`

type CreateJobDetailsParams struct {
	Jobdetailid     string
	Postid          string
	Jobtype         string
	Salarytype      sql.NullString
	Salaryamountmin sql.NullInt64
	Salaryamountmax sql.NullInt64
	Salarycurrency  sql.NullString
}

func (q *Queries) CreateJobDetails(ctx context.Context, arg CreateJobDetailsParams) error {
	_, err := q.db.ExecContext(ctx, createJobDetails,
		arg.Jobdetailid,
		arg.Postid,
		arg.Jobtype,
		arg.Salarytype,
		arg.Salaryamountmin,
		arg.Salaryamountmax,
		arg.Salarycurrency,
	)
	return err
}

const createPost = `-- name: CreatePost :exec
INSERT INTO posts (
    postId, 
    title, 
    description, 
    additionalInfoLink, 
    workSetup, 
    deadline, 
    addressId, 
    orgId,
    embedding
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, vector32(?)
)
`

type CreatePostParams struct {
	Postid             string
	Title              string
	Description        sql.NullString
	Additionalinfolink sql.NullString
	Worksetup          string
	Deadline           sql.NullInt64
	Addressid          string
	Orgid              string
	Embedding          interface{}
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) error {
	_, err := q.db.ExecContext(ctx, createPost,
		arg.Postid,
		arg.Title,
		arg.Description,
		arg.Additionalinfolink,
		arg.Worksetup,
		arg.Deadline,
		arg.Addressid,
		arg.Orgid,
		arg.Embedding,
	)
	return err
}

const createPostRequirement = `-- name: CreatePostRequirement :exec
INSERT INTO post_requirements (
    requirementId,
    postId,
    requirementType,
    requirement
) VALUES (
    ?, ?, ?, ?
)
RETURNING requirementid, postid, requirementtype, requirement, created_at, updated_at
`

type CreatePostRequirementParams struct {
	Requirementid   string
	Postid          string
	Requirementtype string
	Requirement     string
}

func (q *Queries) CreatePostRequirement(ctx context.Context, arg CreatePostRequirementParams) error {
	_, err := q.db.ExecContext(ctx, createPostRequirement,
		arg.Requirementid,
		arg.Postid,
		arg.Requirementtype,
		arg.Requirement,
	)
	return err
}

const createPostTag = `-- name: CreatePostTag :exec
INSERT INTO post_tags (
    tagId, 
    postId, 
    tagName, 
    tagCategory
) VALUES (
    ?,
    ?,
    ?,
    ?
) RETURNING tagid, postid, tagname, tagcategory, created_at, updated_at
`

type CreatePostTagParams struct {
	Tagid       string
	Postid      string
	Tagname     string
	Tagcategory sql.NullString
}

func (q *Queries) CreatePostTag(ctx context.Context, arg CreatePostTagParams) error {
	_, err := q.db.ExecContext(ctx, createPostTag,
		arg.Tagid,
		arg.Postid,
		arg.Tagname,
		arg.Tagcategory,
	)
	return err
}

const createSavedPost = `-- name: CreateSavedPost :exec
INSERT INTO saved_posts (
    savedPostId, postId, userId
) VALUES (
    ?, ?, ?
) RETURNING savedpostid, postid, userid, created_at, updated_at
`

type CreateSavedPostParams struct {
	Savedpostid string
	Postid      string
	Userid      string
}

func (q *Queries) CreateSavedPost(ctx context.Context, arg CreateSavedPostParams) error {
	_, err := q.db.ExecContext(ctx, createSavedPost, arg.Savedpostid, arg.Postid, arg.Userid)
	return err
}

const deleteSavedPost = `-- name: DeleteSavedPost :exec
DELETE FROM saved_posts 
WHERE userId = ? AND postId = ?
`

type DeleteSavedPostParams struct {
	Userid string
	Postid string
}

func (q *Queries) DeleteSavedPost(ctx context.Context, arg DeleteSavedPostParams) error {
	_, err := q.db.ExecContext(ctx, deleteSavedPost, arg.Userid, arg.Postid)
	return err
}

const getPostCountByOrgId = `-- name: GetPostCountByOrgId :one
SELECT  
    COUNT(*) AS total_count
FROM posts
WHERE orgId = ?
`

func (q *Queries) GetPostCountByOrgId(ctx context.Context, orgid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostCountByOrgId, orgid)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getPostDetailsByPostId = `-- name: GetPostDetailsByPostId :one
SELECT  
  posts.postId,
    posts.title,
    posts.description,
    posts.additionalInfoLink,
    organizations.company,
    posts.workSetup,
    job_details.jobType,
    job_details.salaryAmountMin,
    job_details.salaryAmountMax,
    job_details.salaryCurrency,
    job_details.salaryType,
    addresses.country,
    addresses.city,
    COALESCE(GROUP_CONCAT(post_tags.tagName, ', '), '') AS tags,
    posts.posted_at
FROM posts
JOIN addresses ON posts.addressId = addresses.addressId
JOIN organizations ON posts.orgId = organizations.orgId
LEFT JOIN post_tags ON posts.postId = post_tags.postId
LEFT JOIN job_details ON posts.postId = job_details.postId
WHERE posts.postId = ?
`

type GetPostDetailsByPostIdRow struct {
	Postid             string
	Title              string
	Description        sql.NullString
	Additionalinfolink sql.NullString
	Company            string
	Worksetup          string
	Jobtype            sql.NullString
	Salaryamountmin    sql.NullInt64
	Salaryamountmax    sql.NullInt64
	Salarycurrency     sql.NullString
	Salarytype         sql.NullString
	Country            string
	City               sql.NullString
	Tags               interface{}
	PostedAt           sql.NullTime
}

func (q *Queries) GetPostDetailsByPostId(ctx context.Context, postid string) (GetPostDetailsByPostIdRow, error) {
	row := q.db.QueryRowContext(ctx, getPostDetailsByPostId, postid)
	var i GetPostDetailsByPostIdRow
	err := row.Scan(
		&i.Postid,
		&i.Title,
		&i.Description,
		&i.Additionalinfolink,
		&i.Company,
		&i.Worksetup,
		&i.Jobtype,
		&i.Salaryamountmin,
		&i.Salaryamountmax,
		&i.Salarycurrency,
		&i.Salarytype,
		&i.Country,
		&i.City,
		&i.Tags,
		&i.PostedAt,
	)
	return i, err
}

const getPostRequirements = `-- name: GetPostRequirements :many
SELECT 
    requirementType,
    requirement
FROM post_requirements
WHERE postId = ?
`

type GetPostRequirementsRow struct {
	Requirementtype string
	Requirement     string
}

func (q *Queries) GetPostRequirements(ctx context.Context, postid string) ([]GetPostRequirementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostRequirements, postid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostRequirementsRow
	for rows.Next() {
		var i GetPostRequirementsRow
		if err := rows.Scan(&i.Requirementtype, &i.Requirement); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByOrgId = `-- name: GetPostsByOrgId :many
SELECT  
    p.postId,
    p.title,
    p.deadline,
    o.company
FROM posts p
LEFT JOIN organizations o
ON p.orgId = o.orgId
WHERE p.orgId = ?
ORDER BY p.posted_at DESC
LIMIT 10 OFFSET ?
`

type GetPostsByOrgIdParams struct {
	Orgid  string
	Offset int64
}

type GetPostsByOrgIdRow struct {
	Postid   string
	Title    string
	Deadline sql.NullInt64
	Company  sql.NullString
}

func (q *Queries) GetPostsByOrgId(ctx context.Context, arg GetPostsByOrgIdParams) ([]GetPostsByOrgIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByOrgId, arg.Orgid, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsByOrgIdRow
	for rows.Next() {
		var i GetPostsByOrgIdRow
		if err := rows.Scan(
			&i.Postid,
			&i.Title,
			&i.Deadline,
			&i.Company,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSavedPostsByUserAndPostIDs = `-- name: GetSavedPostsByUserAndPostIDs :many
SELECT savedPostId, postId
FROM saved_posts
WHERE userId = ?
AND postId IN (/*SLICE:postids*/?)
`

type GetSavedPostsByUserAndPostIDsParams struct {
	Userid  string
	Postids []string
}

type GetSavedPostsByUserAndPostIDsRow struct {
	Savedpostid string
	Postid      string
}

func (q *Queries) GetSavedPostsByUserAndPostIDs(ctx context.Context, arg GetSavedPostsByUserAndPostIDsParams) ([]GetSavedPostsByUserAndPostIDsRow, error) {
	query := getSavedPostsByUserAndPostIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Userid)
	if len(arg.Postids) > 0 {
		for _, v := range arg.Postids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:postids*/?", strings.Repeat(",?", len(arg.Postids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:postids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSavedPostsByUserAndPostIDsRow
	for rows.Next() {
		var i GetSavedPostsByUserAndPostIDsRow
		if err := rows.Scan(&i.Savedpostid, &i.Postid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSavedPost = `-- name: GetUserSavedPost :one
SELECT savedPostId 
FROM saved_posts
WHERE userId = ? AND postId = ?
`

type GetUserSavedPostParams struct {
	Userid string
	Postid string
}

func (q *Queries) GetUserSavedPost(ctx context.Context, arg GetUserSavedPostParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserSavedPost, arg.Userid, arg.Postid)
	var savedpostid string
	err := row.Scan(&savedpostid)
	return savedpostid, err
}

const jobSearchQuery = `-- name: JobSearchQuery :many
WITH embedding_vector AS (
    SELECT vector32(?) AS vec
)
SELECT  
    posts.postId,
    posts.title,
    posts.description,
    organizations.company,
    posts.workSetup,
    job_details.jobType,
    job_details.salaryAmountMin,
    job_details.salaryAmountMax,
    job_details.salaryCurrency,
    job_details.salaryType,
    addresses.country,
    addresses.city,
    COALESCE(GROUP_CONCAT(post_tags.tagName, ', '), '') AS tags,
    posts.posted_at
FROM posts, embedding_vector
JOIN addresses ON posts.addressId = addresses.addressId
JOIN organizations ON posts.orgId = organizations.orgId
LEFT JOIN post_tags ON posts.postId = post_tags.postId
LEFT JOIN job_details ON posts.postId = job_details.postId
WHERE 
    vector_distance_cos(posts.embedding, embedding_vector.vec) < 0.6
    AND addresses.country = ?
    AND (? IS NULL OR addresses.province = ?)
    AND (? IS NULL OR addresses.city = ?)
GROUP BY posts.postId
ORDER BY vector_distance_cos(embedding, embedding_vector.vec) ASC
LIMIT 10 OFFSET ?
`

type JobSearchQueryParams struct {
	Embedding    interface{}
	Country      string
	Provincenull interface{}
	Province     sql.NullString
	Citynull     interface{}
	City         sql.NullString
	Offset       int64
}

type JobSearchQueryRow struct {
	Postid          string
	Title           string
	Description     sql.NullString
	Company         string
	Worksetup       string
	Jobtype         sql.NullString
	Salaryamountmin sql.NullInt64
	Salaryamountmax sql.NullInt64
	Salarycurrency  sql.NullString
	Salarytype      sql.NullString
	Country         string
	City            sql.NullString
	Tags            interface{}
	PostedAt        sql.NullTime
}

func (q *Queries) JobSearchQuery(ctx context.Context, arg JobSearchQueryParams) ([]JobSearchQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, jobSearchQuery,
		arg.Embedding,
		arg.Country,
		arg.Provincenull,
		arg.Province,
		arg.Citynull,
		arg.City,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobSearchQueryRow
	for rows.Next() {
		var i JobSearchQueryRow
		if err := rows.Scan(
			&i.Postid,
			&i.Title,
			&i.Description,
			&i.Company,
			&i.Worksetup,
			&i.Jobtype,
			&i.Salaryamountmin,
			&i.Salaryamountmax,
			&i.Salarycurrency,
			&i.Salarytype,
			&i.Country,
			&i.City,
			&i.Tags,
			&i.PostedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostAdditionalInfoLink = `-- name: UpdatePostAdditionalInfoLink :exec
UPDATE posts
SET additionalInfoLink = ?
WHERE postId = ? AND orgId = ?
`

type UpdatePostAdditionalInfoLinkParams struct {
	Additionalinfolink sql.NullString
	Postid             string
	Orgid              string
}

func (q *Queries) UpdatePostAdditionalInfoLink(ctx context.Context, arg UpdatePostAdditionalInfoLinkParams) error {
	_, err := q.db.ExecContext(ctx, updatePostAdditionalInfoLink, arg.Additionalinfolink, arg.Postid, arg.Orgid)
	return err
}
