import { getSiteUrl } from "./utils";

export const main_backend = async ({
  bucket,
  poolId,
  poolClientId,
  poolClientSecret,
  cloudFrontUrl,
  poolDomain,
}: {
  bucket: $util.Output<string>;
  poolId: $util.Output<string>;
  poolClientId: $util.Output<string>;
  poolClientSecret: $util.Output<string>;
  cloudFrontUrl: $util.Output<string>;
  poolDomain: $util.Output<string>;
}) => {
  const callerIdentity = aws.getCallerIdentity();
  const accountId = await callerIdentity.then((identity) => identity.accountId);

  const baseDomain = getSiteUrl();

  const backendFunction = new sst.aws.Function(
    `${process.env.PROJ_NAME}Lambda`,
    {
      runtime: "go",
      handler: "packages/backend",
      dev: false,

      permissions: [
        {
          actions: [
            "logs:CreateLogGroup",
            "logs:CreateLogStream",
            "logs:PutLogEvents",
          ],
          effect: "allow",
          resources: ["*"],
        },
        {
          actions: ["cognito-idp:*"],
          effect: "allow",
          resources: [
            `arn:aws:cognito-idp:${aws.config.region}:${accountId}:userpool/*`,
          ],
        },
      ],

      environment: {
        POOL_ID: poolId,
        POOL_CLIENT_ID: poolClientId,
        POOL_CLIENT_SECRET: poolClientSecret,
        POOL_DOMAIN: poolDomain.apply(
          (v) => `https://${v}.auth.${aws.config.region}.amazoncognito.com`
        ),
        IDP_REDIRECT_URI: baseDomain.apply((v) => v + "/sign-in"),

        ALLOWED_ORIGINS: baseDomain,
        DOMAIN: process.env.DOMAIN ?? "localhost",
        AUTH_SESSION_SECRET: process.env.AUTH_SESSION_SECRET,

        DB_URL: process.env.DB_URL,
        ASSET_BUCKET: bucket,
        CLOUDFRONT_URL: cloudFrontUrl.apply((v) => "https://" + v),

        OPENAI_API_KEY: process.env.OPENAI_API_KEY,
      },
    }
  );

  // Create an API Gateway
  const api = new aws.apigatewayv2.Api(`${process.env.PROJ_NAME}APIGateway`, {
    protocolType: "HTTP",
  });

  const integration = new aws.apigatewayv2.Integration(
    `${process.env.PROJ_NAME}APIGatewayIntegration`,
    {
      apiId: api.id,
      integrationType: "AWS_PROXY",
      integrationUri: backendFunction.arn,
      integrationMethod: "ANY",
      payloadFormatVersion: "2.0",
      passthroughBehavior: "WHEN_NO_TEMPLATES",
    }
  );

  new aws.apigatewayv2.Route(`${process.env.PROJ_NAME}APIGatewayRoute`, {
    apiId: api.id,
    routeKey: "$default",
    target: $util.interpolate`integrations/${integration.id}`,
  });

  const apiStage = new aws.apigatewayv2.Stage(
    `${process.env.PROJ_NAME}APIGatewayDeployment`,
    {
      apiId: api.id,
      autoDeploy: true,
      name: "$default",
    }
  );

  // Grant permissions
  new aws.lambda.Permission(`${process.env.PROJ_NAME}APIGatewayPermssions`, {
    action: "lambda:InvokeFunction",
    function: backendFunction.nodes.function,
    principal: "apigateway.amazonaws.com",
    sourceArn: $util.interpolate`${api.executionArn}/*/*`,
  });

  if (!["production", "preview"].includes($app.stage))
    return {
      apiUrl: api.apiEndpoint,
      functionName: backendFunction.name,
    };

  // Custom Domain
  const domainName = `api${$app.stage === "production" ? "." : `-${$app.stage}.`}${process.env.DOMAIN}`;

  const customDomain = new aws.apigatewayv2.DomainName("CustomDomain", {
    domainName,
    domainNameConfiguration: {
      certificateArn: process.env.ACM_ARN,
      endpointType: "REGIONAL", // or "EDGE" depending on your requirements
      securityPolicy: "TLS_1_2",
    },
  });

  new aws.apigatewayv2.ApiMapping("ApiDomainMapping", {
    apiId: api.id,
    domainName: customDomain.id,
    stage: apiStage.name,
  });

  // Add the Route 53 DNS record
  new aws.route53.Record("apiDnsRecord", {
    name: domainName,
    type: "CNAME",
    zoneId: process.env.ZONE_ID,
    records: [customDomain.domainNameConfiguration.targetDomainName], // Generated by API Gateway
    ttl: 300,
  });

  return {
    apiUrl: domainName,
    functionName: backendFunction.name,
  };
};
